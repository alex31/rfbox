#include "modeTest.hpp"
#include "bboard.hpp"
#include "bitIntegrator.hpp"
#include "ch.h"
#include "etl/string.h"
#include "frozen/map.h"
#include "frozen/set.h"
#include "hal.h"
#include "hardwareConf.hpp"
#include "radio.hpp"
#include "stdutil.h"
#include <array>
#include <bit>
#include <limits>

namespace {
using ErrorString = etl::string<48>;
THD_WORKING_AREA(waAutonomousTest, 1280);

SerialConfig meteoSerialConfig = {
    .speed = baudRates[+BitRateIndex::Low],
    .cr1 = 0,
    .cr2 = USART_CR2_STOP1_BITS | USART_CR2_LINEN | invertOokModulation
               ? (USART_CR2_TXINV | USART_CR2_RXINV)
               : 0,
    .cr3 = 0};

bool started = false;
void autonomousTestWrite(void *);
void autonomousTestRead(void *);
Integrator<1024> integ;

systime_t timoutTs = 0;

constexpr std::array<uint16_t, 250> seq2dcfGen = {
    0x36a6, 0x359a, 0x5996, 0x9969, 0xa556, 0x6553, 0x3653, 0x4da9, 0x26ad,
    0x26b6, 0x329b, 0x25ab, 0x65a6, 0x552d, 0xb296, 0x4ab3, 0x994b, 0x3695,
    0x334b, 0x992b, 0x4da6, 0xb24b, 0x52b6, 0x3395, 0x93a9, 0x4d53, 0x66a9,
    0x26ab, 0x59a6, 0x5596, 0x29ab, 0x929b, 0x496d, 0xaa2d, 0x9396, 0x3595,
    0x999a, 0x33a9, 0x2a6b, 0x92b3, 0x4d96, 0xa55a, 0x595a, 0x3396, 0x55a6,
    0x6569, 0x992d, 0x33a6, 0x662b, 0xa569, 0xaa4b, 0x6696, 0x529b, 0x25b3,
    0x495b, 0x4ab5, 0x9995, 0x592d, 0x49b6, 0x559a, 0x932b, 0x29ad, 0xaa96,
    0x2aad, 0x554b, 0x934b, 0x9953, 0x299b, 0x5956, 0x36a9, 0x92b5, 0x296b,
    0xaa2b, 0x9996, 0xa52b, 0xaa6a, 0x5595, 0x325b, 0x9395, 0xb256, 0x32b5,
    0xa596, 0x336a, 0x366a, 0x52b3, 0x4a9b, 0xaa95, 0x556a, 0x65a9, 0x3353,
    0x4aad, 0x3596, 0x4d4b, 0x656a, 0x49b5, 0x4a5b, 0x9956, 0x3656, 0x356a,
    0x9353, 0x592b, 0xb25a, 0xb29a, 0x326b, 0x6656, 0x32ab, 0x352b, 0x369a,
    0x269b, 0x2aab, 0xb269, 0xa56a, 0x3356, 0x995a, 0x3569, 0xaaa6, 0x6596,
    0x99a9, 0x5969, 0x354b, 0x652d, 0x4d2d, 0x4d2b, 0x92ad, 0xb22d, 0x666a,
    0x2ab3, 0x5553, 0x259b, 0x49ad, 0xa553, 0xa595, 0x2a6d, 0x296d, 0x939a,
    0x29b5, 0x99a6, 0x335a, 0x9369, 0x332b, 0x5556, 0x266b, 0x362b, 0x364b,
    0x996a, 0x59a9, 0x555a, 0x25ad, 0x926b, 0x4d5a, 0x652b, 0x4d95, 0x664b,
    0x525b, 0xaa69, 0x932d, 0x6669, 0x4aab, 0x295b, 0x25b5, 0x4ab6, 0x352d,
    0x594b, 0x552b, 0x2ab6, 0x49ab, 0x935a, 0x4d6a, 0x2a5b, 0xb2a9, 0x3669,
    0x26b5, 0x255b, 0xaa5a, 0x92ab, 0x52ad, 0x32b3, 0xaa56, 0x6695, 0x496b,
    0x32b6, 0x49b3, 0x326d, 0x32ad, 0x29b3, 0x669a, 0x4a6d, 0xa5a6, 0x52ab,
    0x654b, 0x6653, 0x92b6, 0x925b, 0x3556, 0xa59a, 0xb22b, 0xb253, 0x355a,
    0xa52d, 0x526b, 0x5953, 0x3696, 0xb2a6, 0xa54b, 0x4d69, 0x93a6, 0xaa9a,
    0x655a, 0x4a6b, 0x55a9, 0x526d, 0x339a, 0x256d, 0x659a, 0x4d56, 0x662d,
    0x362d, 0x5995, 0x665a, 0x29b6, 0x3369, 0x499b, 0x4d9a, 0xa5a9, 0x265b,
    0xb295, 0xaaa9, 0xb26a, 0x926d, 0x596a, 0x35a6, 0x2a9b, 0x9356, 0x936a,
    0x26b3, 0xaa53, 0x52b5, 0x6556, 0x332d, 0x266d, 0x6595, 0x2ab5, 0x66a6,
    0x5569, 0x35a9, 0x25b6, 0x365a, 0x599a, 0x3553, 0x256b,
};
constexpr frozen::map<uint16_t, uint8_t, 250> dcf2seqGen = {
    {0x36a6, 0},   {0x359a, 1},   {0x5996, 2},   {0x9969, 3},   {0xa556, 4},
    {0x6553, 5},   {0x3653, 6},   {0x4da9, 7},   {0x26ad, 8},   {0x26b6, 9},
    {0x329b, 10},  {0x25ab, 11},  {0x65a6, 12},  {0x552d, 13},  {0xb296, 14},
    {0x4ab3, 15},  {0x994b, 16},  {0x3695, 17},  {0x334b, 18},  {0x992b, 19},
    {0x4da6, 20},  {0xb24b, 21},  {0x52b6, 22},  {0x3395, 23},  {0x93a9, 24},
    {0x4d53, 25},  {0x66a9, 26},  {0x26ab, 27},  {0x59a6, 28},  {0x5596, 29},
    {0x29ab, 30},  {0x929b, 31},  {0x496d, 32},  {0xaa2d, 33},  {0x9396, 34},
    {0x3595, 35},  {0x999a, 36},  {0x33a9, 37},  {0x2a6b, 38},  {0x92b3, 39},
    {0x4d96, 40},  {0xa55a, 41},  {0x595a, 42},  {0x3396, 43},  {0x55a6, 44},
    {0x6569, 45},  {0x992d, 46},  {0x33a6, 47},  {0x662b, 48},  {0xa569, 49},
    {0xaa4b, 50},  {0x6696, 51},  {0x529b, 52},  {0x25b3, 53},  {0x495b, 54},
    {0x4ab5, 55},  {0x9995, 56},  {0x592d, 57},  {0x49b6, 58},  {0x559a, 59},
    {0x932b, 60},  {0x29ad, 61},  {0xaa96, 62},  {0x2aad, 63},  {0x554b, 64},
    {0x934b, 65},  {0x9953, 66},  {0x299b, 67},  {0x5956, 68},  {0x36a9, 69},
    {0x92b5, 70},  {0x296b, 71},  {0xaa2b, 72},  {0x9996, 73},  {0xa52b, 74},
    {0xaa6a, 75},  {0x5595, 76},  {0x325b, 77},  {0x9395, 78},  {0xb256, 79},
    {0x32b5, 80},  {0xa596, 81},  {0x336a, 82},  {0x366a, 83},  {0x52b3, 84},
    {0x4a9b, 85},  {0xaa95, 86},  {0x556a, 87},  {0x65a9, 88},  {0x3353, 89},
    {0x4aad, 90},  {0x3596, 91},  {0x4d4b, 92},  {0x656a, 93},  {0x49b5, 94},
    {0x4a5b, 95},  {0x9956, 96},  {0x3656, 97},  {0x356a, 98},  {0x9353, 99},
    {0x592b, 100}, {0xb25a, 101}, {0xb29a, 102}, {0x326b, 103}, {0x6656, 104},
    {0x32ab, 105}, {0x352b, 106}, {0x369a, 107}, {0x269b, 108}, {0x2aab, 109},
    {0xb269, 110}, {0xa56a, 111}, {0x3356, 112}, {0x995a, 113}, {0x3569, 114},
    {0xaaa6, 115}, {0x6596, 116}, {0x99a9, 117}, {0x5969, 118}, {0x354b, 119},
    {0x652d, 120}, {0x4d2d, 121}, {0x4d2b, 122}, {0x92ad, 123}, {0xb22d, 124},
    {0x666a, 125}, {0x2ab3, 126}, {0x5553, 127}, {0x259b, 128}, {0x49ad, 129},
    {0xa553, 130}, {0xa595, 131}, {0x2a6d, 132}, {0x296d, 133}, {0x939a, 134},
    {0x29b5, 135}, {0x99a6, 136}, {0x335a, 137}, {0x9369, 138}, {0x332b, 139},
    {0x5556, 140}, {0x266b, 141}, {0x362b, 142}, {0x364b, 143}, {0x996a, 144},
    {0x59a9, 145}, {0x555a, 146}, {0x25ad, 147}, {0x926b, 148}, {0x4d5a, 149},
    {0x652b, 150}, {0x4d95, 151}, {0x664b, 152}, {0x525b, 153}, {0xaa69, 154},
    {0x932d, 155}, {0x6669, 156}, {0x4aab, 157}, {0x295b, 158}, {0x25b5, 159},
    {0x4ab6, 160}, {0x352d, 161}, {0x594b, 162}, {0x552b, 163}, {0x2ab6, 164},
    {0x49ab, 165}, {0x935a, 166}, {0x4d6a, 167}, {0x2a5b, 168}, {0xb2a9, 169},
    {0x3669, 170}, {0x26b5, 171}, {0x255b, 172}, {0xaa5a, 173}, {0x92ab, 174},
    {0x52ad, 175}, {0x32b3, 176}, {0xaa56, 177}, {0x6695, 178}, {0x496b, 179},
    {0x32b6, 180}, {0x49b3, 181}, {0x326d, 182}, {0x32ad, 183}, {0x29b3, 184},
    {0x669a, 185}, {0x4a6d, 186}, {0xa5a6, 187}, {0x52ab, 188}, {0x654b, 189},
    {0x6653, 190}, {0x92b6, 191}, {0x925b, 192}, {0x3556, 193}, {0xa59a, 194},
    {0xb22b, 195}, {0xb253, 196}, {0x355a, 197}, {0xa52d, 198}, {0x526b, 199},
    {0x5953, 200}, {0x3696, 201}, {0xb2a6, 202}, {0xa54b, 203}, {0x4d69, 204},
    {0x93a6, 205}, {0xaa9a, 206}, {0x655a, 207}, {0x4a6b, 208}, {0x55a9, 209},
    {0x526d, 210}, {0x339a, 211}, {0x256d, 212}, {0x659a, 213}, {0x4d56, 214},
    {0x662d, 215}, {0x362d, 216}, {0x5995, 217}, {0x665a, 218}, {0x29b6, 219},
    {0x3369, 220}, {0x499b, 221}, {0x4d9a, 222}, {0xa5a9, 223}, {0x265b, 224},
    {0xb295, 225}, {0xaaa9, 226}, {0xb26a, 227}, {0x926d, 228}, {0x596a, 229},
    {0x35a6, 230}, {0x2a9b, 231}, {0x9356, 232}, {0x936a, 233}, {0x26b3, 234},
    {0xaa53, 235}, {0x52b5, 236}, {0x6556, 237}, {0x332d, 238}, {0x266d, 239},
    {0x6595, 240}, {0x2ab5, 241}, {0x66a6, 242}, {0x5569, 243}, {0x35a9, 244},
    {0x25b6, 245}, {0x365a, 246}, {0x599a, 247}, {0x3553, 248}, {0x256b, 249},
};
constexpr frozen::set<uint8_t, 22> lsbValid = {
    0x2b, 0x2d, 0x4b, 0x53, 0x56, 0x5a, 0x5b, 0x69, 0x6a, 0x6b, 0x6d,
    0x95, 0x96, 0x9a, 0x9b, 0xa6, 0xa9, 0xab, 0xad, 0xb3, 0xb5, 0xb6,
};
constexpr frozen::set<uint8_t, 22> msbValid = {
    0x25, 0x26, 0x29, 0x2a, 0x32, 0x33, 0x35, 0x36, 0x49, 0x4a, 0x4d,
    0x52, 0x55, 0x59, 0x65, 0x66, 0x92, 0x93, 0x99, 0xa5, 0xaa, 0xb2,
};

constexpr uint16_t checkTables() {
  uint8_t it = 0;
  for (const auto seq : seq2dcfGen) {
    if (not dcf2seqGen.contains(seq))
      return seq;
    if (not(dcf2seqGen.at(seq) == it++))
      return seq;
    if (not lsbValid.contains(seq & 0xff))
      return seq;
    if (not msbValid.contains((seq & 0xff00) >> 8))
      return seq;
  }
  return 0;
}

} // namespace

namespace ModeTest {
float getBer(void) {
  const float ber = integ.getAvg() * 1000.0f;
  board.setBer(ber);
  return ber;
}

void start(RfMode rfMode, uint32_t baud) {
  static_assert(checkTables() == 0);
  board.setDio2Threshold({0.48f, 0.62f});
  meteoSerialConfig.speed = baud;
  // DIO is connected on UART1_TX
  if (rfMode == RfMode::RX)
    meteoSerialConfig.cr2 |= USART_CR2_SWAP;

  sdStart(&SD_METEO, &meteoSerialConfig);
  if (not started) {
    started = true;
    if (rfMode == RfMode::TX) {
      chThdCreateStatic(waAutonomousTest, sizeof(waAutonomousTest), NORMALPRIO,
                        &autonomousTestWrite, nullptr);
    } else if (rfMode == RfMode::RX) {
      chThdCreateStatic(waAutonomousTest, sizeof(waAutonomousTest), NORMALPRIO,
                        &autonomousTestRead, nullptr);
    } else {
      chSysHalt("invalid rfMode");
    }
  }
}
} // namespace ModeTest

namespace {

void autonomousTestWrite(void *) {
  chRegSetThreadName("autonomousTestWrite");
  while (true) {
    sdWrite(&SD_METEO, reinterpret_cast<const uint8_t *>(seq2dcfGen.data()),
            seq2dcfGen.size() * sizeof(seq2dcfGen[0]));
  }
}

void autonomousTestRead(void *) {
  chRegSetThreadName("autonomousTestRead");
  uint8_t expectedByte = 0;
  uint32_t zeroInRow = 0;
  systime_t ts = chVTGetSystemTimeX();

  while (true) {
    const int lsb = sdGetTimeout(&SD_METEO, TIME_MS2I(200));
    if (const systime_t now = chVTGetSystemTimeX();
        chTimeDiffX(ts, now) > TIME_MS2I(500)) {
      ts = now;
      ModeTest::getBer();
    }
    if (lsb < 0) {
      if ((++zeroInRow) > 100U) {
        zeroInRow = 0;
        DebugTrace("problem detected : Read Timeout");
        board.setError("Read Timeout");
      }

      if (chTimeDiffX(timoutTs, chVTGetSystemTimeX()) > TIME_S2I(5)) {
        timoutTs = 0;
      } else {
        timoutTs = chVTGetSystemTimeX();
      }
      board.setError("RX timeout");
      integ.push(true);
    } else if (lsb == 0) {
      if ((++zeroInRow) > 10U) {
        integ.push(true);
        zeroInRow = 0;
        DebugTrace("problem detected : Read only 0");
        board.setError("Read only 0");
        //	  Radio::radio.calibrate();
      }
    } else {
      zeroInRow = 0;
      board.clearError();
      timoutTs = 0;
      if (not lsbValid.contains(lsb)) {
	integ.push(true);
        continue;
      }
      const int msb = sdGetTimeout(&SD_METEO, TIME_MS2I(200));
      if (not msbValid.contains(msb)) {
	integ.push(true);
        continue;
      }
      uint16_t balancedWord = (lsb & 0xff) | ((msb & 0xff) << 8);
      uint8_t c = 0;
      if (dcf2seqGen.contains(balancedWord)) {
        c = dcf2seqGen.at(balancedWord);
      } else {
        integ.push(true);
        continue;
      }
      integ.push(c != expectedByte);
      expectedByte = (c + 1) % dcf2seqGen.size();
    }
  }
}

} // namespace
